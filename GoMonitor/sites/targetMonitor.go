package TargetMonitor

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/bradhe/stopwatch"
	"github.com/elgs/gojq"
	"github.com/nickname32/discordhook"
	"github.com/pkg/errors"
	Webhook "github.con/prada-monitors-go/helpers/discordWebhook"
	FetchProxies "github.con/prada-monitors-go/helpers/proxy"
	Types "github.con/prada-monitors-go/helpers/types"
)

type Autogenerated struct {
	Data struct {
		Product struct {
			Typename        string `json:"__typename"`
			Tcin            string `json:"tcin"`
			NotifyMeEnabled bool   `json:"notify_me_enabled"`
			StorePositions  []struct {
				Aisle int    `json:"aisle"`
				Block string `json:"block"`
			} `json:"store_positions"`
			Fulfillment struct {
				ProductID                       string `json:"product_id"`
				IsOutOfStockInAllStoreLocations bool   `json:"is_out_of_stock_in_all_store_locations"`
				StoreOptions                    []struct {
					LocationName                       string  `json:"location_name"`
					LocationAddress                    string  `json:"location_address"`
					LocationID                         string  `json:"location_id"`
					SearchResponseStoreType            string  `json:"search_response_store_type"`
					LocationAvailableToPromiseQuantity float64 `json:"location_available_to_promise_quantity"`
					OrderPickup                        struct {
						PickupDate         string `json:"pickup_date"`
						GuestPickSLA       int    `json:"guest_pick_sla"`
						AvailabilityStatus string `json:"availability_status"`
					} `json:"order_pickup"`
					InStoreOnly struct {
						AvailabilityStatus string `json:"availability_status"`
					} `json:"in_store_only"`
				} `json:"store_options"`
				ShippingOptions struct {
					AvailabilityStatus         string  `json:"availability_status"`
					LoyaltyAvailabilityStatus  string  `json:"loyalty_availability_status"`
					AvailableToPromiseQuantity float64 `json:"available_to_promise_quantity"`
					MinimumOrderQuantity       float64 `json:"minimum_order_quantity"`
					Services                   []struct {
						IsTwoDayShipping               bool      `json:"is_two_day_shipping"`
						IsBaseShippingMethod           bool      `json:"is_base_shipping_method"`
						ShippingMethodID               string    `json:"shipping_method_id"`
						Cutoff                         time.Time `json:"cutoff"`
						MaxDeliveryDate                string    `json:"max_delivery_date"`
						MinDeliveryDate                string    `json:"min_delivery_date"`
						ShippingMethodShortDescription string    `json:"shipping_method_short_description"`
						ServiceLevelDescription        string    `json:"service_level_description"`
					} `json:"services"`
				} `json:"shipping_options"`
				ScheduledDelivery struct {
					AvailabilityStatus string `json:"availability_status"`
				} `json:"scheduled_delivery"`
			} `json:"fulfillment"`
		} `json:"product"`
	} `json:"data"`
}
type MyJsonName struct {
	Data struct {
		Product struct {
			Typename string `json:"__typename"`
			Item     struct {
				Enrichment struct {
					BuyURL string `json:"buy_url"`
					Images struct {
						AlternateImageUrls []string `json:"alternate_image_urls"`
						AlternateImages    []string `json:"alternate_images"`
						BaseURL            string   `json:"base_url"`
						ContentLabels      []struct {
							ImageURL string `json:"image_url"`
						} `json:"content_labels"`
						PrimaryImage    string `json:"primary_image"`
						PrimaryImageURL string `json:"primary_image_url"`
					} `json:"images"`
				} `json:"enrichment"`
				ProductDescription struct {
					BulletDescriptions    []string `json:"bullet_descriptions"`
					DownstreamDescription string   `json:"downstream_description"`
					SoftBulletDescription string   `json:"soft_bullet_description"`
					SoftBullets           struct {
						Bullets []string `json:"bullets"`
						Title   string   `json:"title"`
					} `json:"soft_bullets"`
					Title string `json:"title"`
				} `json:"product_description"`
				ProductVendors []struct {
					ID         string `json:"id"`
					VendorName string `json:"vendor_name"`
				} `json:"product_vendors"`
				RelationshipTypeCode       string   `json:"relationship_type_code"`
				ReturnPoliciesGuestMessage string   `json:"return_policies_guest_message"`
				Ribbons                    []string `json:"ribbons"`
			} `json:"item"`
			Price struct {
				CurrentRetail             float64 `json:"current_retail"`
				FormattedCurrentPrice     string  `json:"formatted_current_price"`
				FormattedCurrentPriceType string  `json:"formatted_current_price_type"`
				IsCurrentPriceRange       bool    `json:"is_current_price_range"`
			} `json:"price"`
			TargetFinds struct{} `json:"target_finds"`
			Tcin        string   `json:"tcin"`
		} `json:"product"`
	} `json:"data"`
}

type Product struct {
	name        string
	stockNumber int
	offerId     string
	price       int
	image       string
	isLoaded    bool
}
type Proxy struct {
	ip       string
	port     string
	userAuth string
	userPass string
}
type ItemInMonitorJson struct {
	Sku       string `json:"sku"`
	Site      string `json:"site"`
	Stop      bool   `json:"stop"`
	Name      string `json:"name"`
	Companies []Company
}
type Company struct {
	Company      string `json:"company"`
	Webhook      string `json:"webhook"`
	Color        string `json:"color"`
	CompanyImage string `json:"companyImage"`
}
type CurrentMonitor struct {
	Monitor            Types.Monitor
	IsLoaded           bool
	IsRedCardExclusive bool
	PromotionMessage   string
}

func NewMonitor(sku string, priceRangeMin int, priceRangeMax int) *CurrentMonitor {
	// defer func() {
	// 	if r := recover(); r != nil {
	// 		fmt.Printf("Site : %s, Product : %s NEW MONITOR Recovering from panic in printAllOperations error is: %v \n", sku, sku, r)
	// 	}
	// }()
	fmt.Println("Target Monitor", sku, priceRangeMin, priceRangeMax)
	m := CurrentMonitor{}
	m.Monitor.AvailabilityBool = false
	m.Monitor.Config.Site = "Target"
	m.Monitor.Config.StartDelay = 3000
	m.Monitor.Config.Sku = sku
	m.Monitor.Client = http.Client{Timeout: 10 * time.Second}
	m.Monitor.MonitorProduct.Name = "Testing Product"
	m.Monitor.MonitorProduct.StockNumberInt = 10
	m.Monitor.MonitorProduct.Price = 0
	m.Monitor.MonitorProduct.Image = "https://assets.targetimg1.com/ui/images/349988df76a1d9bf0ccc60310d50d3a5_Basket2x.png"
	m.IsLoaded = true
	m.getProductImage(sku)
	proxyList := FetchProxies.Get()
	i := true
	time.Sleep(15000 * (time.Millisecond))
	go m.Monitor.CheckStop()
	time.Sleep(3000 * (time.Millisecond))
	for i {
		if !m.Monitor.Stop {
			currentProxy := m.Monitor.GetProxy(proxyList)
			splittedProxy := strings.Split(currentProxy, ":")
			proxy := Proxy{splittedProxy[0], splittedProxy[1], splittedProxy[2], splittedProxy[3]}
			prox1y := fmt.Sprintf("http://%s:%s@%s:%s", proxy.userAuth, proxy.userPass, proxy.ip, proxy.port)
			proxyUrl, err := url.Parse(prox1y)
			if err != nil {
				fmt.Println(err)
				return nil
			}
			defaultTransport := &http.Transport{
				Proxy: http.ProxyURL(proxyUrl),
			}
			m.Monitor.Client.Transport = defaultTransport
			m.monitor()
			// time.Sleep(150 * (time.Millisecond))

		} else {
			fmt.Println(m.Monitor.Config.Sku, "STOPPED STOPPED STOPPED")
			i = false
		}
	}
	return &m
}

func (m *CurrentMonitor) monitor() error {
	watch := stopwatch.Start()

	url := fmt.Sprintf("https://redsky.target.com/redsky_aggregations/v1/web/pdp_fulfillment_v1?key=ff457966e64d5e877fdbad070f276d18ecec4a01&tcin=%s&store_id=2067&store_positions_store_id=2067&has_store_positions_store_id=true&scheduled_delivery_store_id=2067&pricing_store_id=2067&fulfillment_test_mode=grocery_opu_team_member_test", m.Monitor.Config.Sku)
	req, err := http.NewRequest("GET", url, nil)

	if err != nil {
		fmt.Println(err)
		return nil
	}

	req.Header.Set("Connection", "close")
	req.Close = true
	res, err := m.Monitor.Client.Do(req)

	if err != nil {
		fmt.Println(err)
		return nil
	}
	defer res.Body.Close()
	defer func() {
		watch.Stop()
		fmt.Printf("Target - Status Code %d : %t  : %s :Loaded : %t %s Milliseconds elapsed: %v \n", res.StatusCode, m.Monitor.AvailabilityBool, m.Monitor.Config.Sku, m.IsLoaded, res.Header["X-Cache"], watch.Milliseconds())
	}()
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		return nil
	}
	if res.StatusCode == 404 || res.StatusCode == 429 {
		if res.StatusCode == 404 {
			m.IsLoaded = false
		}
		return nil
	}

	if !m.IsLoaded {
		m.getProductImage(m.Monitor.Config.Sku)
		go m.sendWebhook()
	}
	m.IsLoaded = true
	var realBody Autogenerated
	err = json.Unmarshal(body, &realBody)
	if err != nil {
		fmt.Println(err)
		return nil
	}
	currentAvailability := realBody.Data.Product.Fulfillment.ShippingOptions.AvailabilityStatus
	if currentAvailability == "PRE_ORDER_UNSELLABLE" || currentAvailability == "UNAVAILABLE" || currentAvailability == "OUT_OF_STOCK" {
		m.Monitor.CurrentAvailabilityBool = false
	} else if currentAvailability == "PRE_ORDER_SELLABLE" || currentAvailability == "IN_STOCK" {
		m.Monitor.CurrentAvailabilityBool = true
	} else {
		m.Monitor.CurrentAvailabilityBool = false
		fmt.Println(currentAvailability)
	}
	m.Monitor.MonitorProduct.StockNumberInt = int(realBody.Data.Product.Fulfillment.ShippingOptions.AvailableToPromiseQuantity)
	if !m.Monitor.AvailabilityBool && m.Monitor.CurrentAvailabilityBool {
		fmt.Println("Item in Stock")
		go m.sendWebhook()
		if m.Monitor.MonitorProduct.Image == "https://assets.targetimg1.com/ui/images/349988df76a1d9bf0ccc60310d50d3a5_Basket2x.png" {
			m.getProductImage(m.Monitor.Config.Sku)
			go m.sendWebhook()
		} else {
			if !m.IsRedCardExclusive {
				m.getProductImage(m.Monitor.Config.Sku)
				if m.IsRedCardExclusive {
					go m.sendWebhook()
				}
			}
		}

	}
	if m.Monitor.AvailabilityBool && !m.Monitor.CurrentAvailabilityBool {
		fmt.Println("Item Out Of Stock")
	}
	m.Monitor.AvailabilityBool = m.Monitor.CurrentAvailabilityBool
	return nil
}

func (m *CurrentMonitor) sendWebhook() error {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("Site : %s, Product : %s SENDING WEBHOOK Recovering from panic in printAllOperations error is: %v \n", m.Monitor.Config.Site, m.Monitor.Config.Sku, r)
		}
	}()
	for _, letter := range m.Monitor.MonitorProduct.Name {
		if string(letter) == `"` {
			m.Monitor.MonitorProduct.Name = strings.Replace(m.Monitor.MonitorProduct.Name, `"`, "", -1)
		}
	}
	t := time.Now().UTC()

	for _, comp := range m.Monitor.CurrentCompanies {
		fmt.Println(comp.Company)
		// fmt.Println(comp.Company)
		link := fmt.Sprintf("https://www.target.com/p/prada/-/A-%s", m.Monitor.Config.Sku)
		go m.sendWeb(comp, m.Monitor.Config.Site, m.Monitor.Config.Sku, m.Monitor.MonitorProduct.Name, m.Monitor.MonitorProduct.Price, link, t, m.Monitor.MonitorProduct.Image, m.Monitor.MonitorProduct.StockNumberInt)
		// go webHookSend(comp, m.Monitor.Config.Site, m.Monitor.Config.Sku, m.Monitor.MonitorProduct.Name, m.Monitor.MonitorProduct.Price, m.Monitor.MonitorProduct.StockNumberInt, t, m.Monitor.MonitorProduct.Image)
	}
	return nil
}

func (m *CurrentMonitor) getProductImage(tcin string) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("Site : %s, Product : %s  GETTING PRODUCT IMAGE Recovering from panic in printAllOperations error is: %v \n", m.Monitor.Config.Site, m.Monitor.Config.Sku, r)
		}
	}()
	fmt.Println("Getting Product Image")
	url := fmt.Sprintf("https://redsky.target.com/redsky_aggregations/v1/web/pdp_client_v1?key=ff457966e64d5e877fdbad070f276d18ecec4a01&tcin=%s&member_id=20032056835&store_id=2067&has_store_id=true&pricing_store_id=2067&has_pricing_store_id=true&scheduled_delivery_store_id=2067&has_scheduled_delivery_store_id=true&has_financing_options=false&visitor_id=0178E7894D540201A352D90ED642CB06&has_size_context=true", tcin)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		fmt.Println(err)
		return
	}
	res, err := m.Monitor.Client.Do(req)
	if err != nil {
		fmt.Println(err)
		res.Body.Close()
		return
	}
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		res.Body.Close()
		return
	}
	if res.StatusCode != 200 {
		fmt.Println("FAILED FETCHING PRODUCT IMAGE : ", m.Monitor.Config.Site, m.Monitor.Config.Sku, res.StatusCode)
		fmt.Println("FAILED FETCHING PRODUCT IMAGE : ", m.Monitor.Config.Site, m.Monitor.Config.Sku, res.StatusCode)
		fmt.Println("FAILED FETCHING PRODUCT IMAGE : ", m.Monitor.Config.Site, m.Monitor.Config.Sku, res.StatusCode)
		fmt.Println("FAILED FETCHING PRODUCT IMAGE : ", m.Monitor.Config.Site, m.Monitor.Config.Sku, res.StatusCode)
		return
	}
	fmt.Println(res.StatusCode)
	var realBody MyJsonName
	err = json.Unmarshal(body, &realBody)
	if err != nil {
		fmt.Println(err, "line 403")
	}
	parser, err := gojq.NewStringQuery(string(body))
	if err != nil {
		fmt.Println(err, "line 401")
	}
	r, err := parser.QueryToString("data.product.promotions.[0].pdp_message")
	if err != nil {
		fmt.Println(err, "line 344")
		m.IsRedCardExclusive = false
		// fmt.Println(v)
		// return
	} else {
		m.IsRedCardExclusive = true
		m.PromotionMessage = r
		fmt.Println(r)
	}
	res.Body.Close()

	m.Monitor.MonitorProduct.Name = realBody.Data.Product.Item.ProductDescription.Title
	m.Monitor.MonitorProduct.Image = realBody.Data.Product.Item.Enrichment.Images.PrimaryImageURL
	m.Monitor.MonitorProduct.Price = int(realBody.Data.Product.Price.CurrentRetail)
	fmt.Println(m.Monitor.MonitorProduct.Image)
}

func (m *CurrentMonitor) sendWeb(c Types.Company, site string, sku string, name string, price int, link string, currentTime time.Time, image string, Qty int) {
	Color, err := strconv.Atoi(c.Color)
	if err != nil {
		fmt.Println(err)
		fmt.Println(errors.Cause(err))
		return
	}
	Quantity := strconv.Itoa(Qty)
	Price := fmt.Sprintf("%d", price)
	var currentFields []*discordhook.EmbedField
	currentFields = append(currentFields, &discordhook.EmbedField{
		Name:   "Product Name",
		Value:  name,
		Inline: false,
	})
	currentFields = append(currentFields, &discordhook.EmbedField{
		Name:   "Tcin",
		Value:  sku,
		Inline: false,
	})
	currentFields = append(currentFields, &discordhook.EmbedField{
		Name:   "Price",
		Value:  Price,
		Inline: true,
	})
	currentFields = append(currentFields, &discordhook.EmbedField{
		Name:   "Stock #",
		Value:  Quantity,
		Inline: true,
	})
	if m.IsRedCardExclusive {
		currentFields = append(currentFields, &discordhook.EmbedField{
			Name:   "Promotions",
			Value:  m.PromotionMessage,
			Inline: true,
		})
	}

	currentFields = append(currentFields, &discordhook.EmbedField{
		Name:  "Links",
		Value: "[Product](" + link + ") | [Cart](https://www.target.com/co-cart)",
	})
	var discordParams discordhook.WebhookExecuteParams = discordhook.WebhookExecuteParams{
		Content: "",
		Embeds: []*discordhook.Embed{
			{
				Title:  site + " Monitor",
				URL:    link,
				Color:  Color,
				Fields: currentFields,
				Footer: &discordhook.EmbedFooter{
					Text: "Prada#4873",
				},
				Timestamp: &currentTime,
				Thumbnail: &discordhook.EmbedThumbnail{
					URL: image,
				},
				Provider: &discordhook.EmbedProvider{
					URL: c.CompanyImage,
				},
			},
		},
	}
	go Webhook.SendWebhook(c.Webhook, &discordParams)
}
func Target(w http.ResponseWriter, r *http.Request) {
	fmt.Println(r.URL)
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintf(w, "Target Monitor")
	var currentMonitor Types.MonitorResponse
	_ = json.NewDecoder(r.Body).Decode(&currentMonitor)
	fmt.Println(currentMonitor)
	go NewMonitor(currentMonitor.Sku, 1, 100000)
	json.NewEncoder(w).Encode(currentMonitor)
}
