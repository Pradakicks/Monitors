package TargetMonitor

import (
	"bufio"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

type Autogenerated struct {
	Data struct {
		Product struct {
			Typename        string `json:"__typename"`
			Tcin            string `json:"tcin"`
			NotifyMeEnabled bool   `json:"notify_me_enabled"`
			StorePositions  []struct {
				Aisle int    `json:"aisle"`
				Block string `json:"block"`
			} `json:"store_positions"`
			Fulfillment struct {
				ProductID                       string `json:"product_id"`
				IsOutOfStockInAllStoreLocations bool   `json:"is_out_of_stock_in_all_store_locations"`
				StoreOptions                    []struct {
					LocationName                       string  `json:"location_name"`
					LocationAddress                    string  `json:"location_address"`
					LocationID                         string  `json:"location_id"`
					SearchResponseStoreType            string  `json:"search_response_store_type"`
					LocationAvailableToPromiseQuantity float64 `json:"location_available_to_promise_quantity"`
					OrderPickup                        struct {
						PickupDate         string `json:"pickup_date"`
						GuestPickSLA       int    `json:"guest_pick_sla"`
						AvailabilityStatus string `json:"availability_status"`
					} `json:"order_pickup"`
					InStoreOnly struct {
						AvailabilityStatus string `json:"availability_status"`
					} `json:"in_store_only"`
				} `json:"store_options"`
				ShippingOptions struct {
					AvailabilityStatus         string  `json:"availability_status"`
					LoyaltyAvailabilityStatus  string  `json:"loyalty_availability_status"`
					AvailableToPromiseQuantity float64 `json:"available_to_promise_quantity"`
					MinimumOrderQuantity       float64 `json:"minimum_order_quantity"`
					Services                   []struct {
						IsTwoDayShipping               bool      `json:"is_two_day_shipping"`
						IsBaseShippingMethod           bool      `json:"is_base_shipping_method"`
						ShippingMethodID               string    `json:"shipping_method_id"`
						Cutoff                         time.Time `json:"cutoff"`
						MaxDeliveryDate                string    `json:"max_delivery_date"`
						MinDeliveryDate                string    `json:"min_delivery_date"`
						ShippingMethodShortDescription string    `json:"shipping_method_short_description"`
						ServiceLevelDescription        string    `json:"service_level_description"`
					} `json:"services"`
				} `json:"shipping_options"`
				ScheduledDelivery struct {
					AvailabilityStatus string `json:"availability_status"`
				} `json:"scheduled_delivery"`
			} `json:"fulfillment"`
		} `json:"product"`
	} `json:"data"`
}

type Config struct {
	tcin       string
	startDelay int
	discord    string
	site string
	image string
}

type Monitor struct {
	Config              Config
	monitorProduct      Product
	Availability        string
	currentAvailability string
	Client              http.Client
	file                *os.File
}
type Product struct {
	name        string
	stockNumber int
}
type Proxy struct {
	ip       string
	port     string
	userAuth string
	userPass string
}

var file os.File

func  TargetMonitor (tcin string){
	go NewMonitor(tcin)
	fmt.Scanln()
}

func NewMonitor(tcin string) *Monitor {
	m := Monitor{}
	
	m.Availability = "OUT_OF_STOCK"
	var err error
	m.Client = http.Client{Timeout: 5 * time.Second}
	m.Config.site = "Target"
	m.Config.startDelay = 3000
	m.Config.tcin = tcin
	m.file, err = os.Create("./testing.txt")
	
	tlsConfig := &tls.Config{
		InsecureSkipVerify : true,
	}

	transport := &http.Transport{
		TLSClientConfig : tlsConfig,
	}

	m.Client = http.Client{
		Timeout: 60 * time.Second,
		Transport : transport,
	}
	m.getProductImage(tcin)
	m.Config.discord = "https://discord.com/api/v8/webhooks/801223334703661068/TuQyXOOa0McqUFH2FohthDH7nSKfol_lQtt460DNXh5qqfwrkGYEM7N2aexGWN9NDtEY?wait=true"
	m.monitorProduct.name = "Teting Product"
	m.monitorProduct.stockNumber = 10
	if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return nil
	}
	defer file.Close()
	// fmt.Println(timeout)
	//m.Availability = "OUT_OF_STOCK"
	//fmt.Println(m)
	i := true
	for i == true {
		currentProxy := getProxy()
		splittedProxy := strings.Split(currentProxy, ":")
		proxy := Proxy{splittedProxy[0], splittedProxy[1], splittedProxy[2], splittedProxy[3]}
		//	fmt.Println(proxy, proxy.ip)
		prox1y := fmt.Sprintf("http://%s:%s@%s:%s", proxy.userAuth, proxy.userPass, proxy.ip, proxy.port)
		proxyUrl, err := url.Parse(prox1y)
		if err != nil {
			fmt.Println(err)
			m.file.WriteString(err.Error() + "\n")
			return nil
		}
		defaultTransport := &http.Transport{
			Proxy: http.ProxyURL(proxyUrl),
		}
		m.Client.Transport = defaultTransport
		go m.monitor()
		time.Sleep(500 * (time.Millisecond))
		fmt.Println(m.Availability)
	}
	return &m
}

func (m *Monitor) monitor() error {
	fmt.Println("Monitoring")

	// url := "https://httpbin.org/ip"

	// req, _ := http.NewRequest("GET", url, nil)

	// res, _ := m.Client.Do(req)

	// defer res.Body.Close()
	// body, _ := ioutil.ReadAll(res.Body)

	// fmt.Println(res)
	// fmt.Println(string(body))

	url := fmt.Sprintf("https://redsky.target.com/redsky_aggregations/v1/web/pdp_fulfillment_v1?key=ff457966e64d5e877fdbad070f276d18ecec4a01&tcin=%s&store_id=2067&store_positions_store_id=2067&has_store_positions_store_id=true&scheduled_delivery_store_id=2067&pricing_store_id=2067&fulfillment_test_mode=grocery_opu_team_member_test", m.Config.tcin)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return nil
	}
	// req.Header.Add("cookie", "TealeafAkaSid=r5S-XRsuxWbk94tkqVB3CruTmaJKz32Z")
	res, err := m.Client.Do(req)
	if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return nil
	}
	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return nil
	}
	//	fmt.Println(res)
	//	fmt.Println(string(body))
	fmt.Println(res.StatusCode)
	var realBody Autogenerated
	err = json.Unmarshal(body, &realBody)
	if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return nil
	}

	m.currentAvailability = realBody.Data.Product.Fulfillment.ShippingOptions.AvailabilityStatus
	// log.Printf("%+v", m.Availability)
	if m.Availability == "OUT_OF_STOCK" && m.currentAvailability == "IN_STOCK" {
		fmt.Println("Item in Stock")
		m.sendWebhook()

	}
	if m.Availability == "IN_STOCK" && m.currentAvailability == "OUT_OF_STOCK" {
		fmt.Println("Item Out Of Stock")
	}
	m.Availability = realBody.Data.Product.Fulfillment.ShippingOptions.AvailabilityStatus
	return nil
}

func getProxy() string {
	path := "test.txt"
	var proxyList = make([]string, 0)
	buf, err := os.Open(path)
	if err != nil {
		log.Fatal(err)
	}

	defer func() {
		if err = buf.Close(); err != nil {
			log.Fatal(err)
		}
	}()

	snl := bufio.NewScanner(buf)
	for snl.Scan() {
		proxy := snl.Text()
		proxyList = append(proxyList, proxy)
		splitProxy := strings.Split(string(proxy), ":")
		newProxy := Proxy{}
		newProxy.userAuth = splitProxy[2]
		newProxy.userPass = splitProxy[3]
		newProxy.ip = splitProxy[0]
		newProxy.port = splitProxy[1]
		//	go NewMonitor(newProxy)
		//	time.Sleep(5 * time.Second)
	}
	err = snl.Err()
	if err != nil {
		fmt.Println(err)
	}
	//fmt.Scanln()
	rand.Seed(time.Now().UnixNano())
	randomPosition := rand.Intn(len(proxyList)-0) + 0
	return proxyList[randomPosition]
}

func (m *Monitor) sendWebhook() error {

	// payload := strings.NewReader("{\"content\":null,\"embeds\":[{\"title\":\"Target Monitor\",\"url\":\"https://discord.com/developers/docs/resources/channel#create-message\",\"color\":507758,\"fields\":[{\"name\":\"Product Name\",\"value\":\"%s\"},{\"name\":\"Product Availability\",\"value\":\"In Stock\\u0021\",\"inline\":true},{\"name\":\"Stock Number\",\"value\":\"%s\",\"inline\":true},{\"name\":\"Links\",\"value\":\"[Product](https://www.walmart.com/ip/prada/%s)\"}],\"footer\":{\"text\":\"Prada#4873\"},\"timestamp\":\"2021-04-01T18:40:00.000Z\",\"thumbnail\":{\"url\":\"https://cdn.discordapp.com/attachments/815507198394105867/816741454922776576/pfp.png\"}}],\"avatar_url\":\"https://cdn.discordapp.com/attachments/815507198394105867/816741454922776576/pfp.png\"}")
	payload := strings.NewReader(fmt.Sprintf("{\"content\":null,\"embeds\":[{\"title\":\"%s Monitor\",\"url\":\"https://discord.com/developers/docs/resources/channel#create-message\",\"color\":507758,\"fields\":[{\"name\":\"Product Name\",\"value\":\"%s\"},{\"name\":\"Product Availability\",\"value\":\"In Stock\\u0021\",\"inline\":true},{\"name\":\"Stock Number\",\"value\":\"%b\",\"inline\":true},{\"name\":\"Links\",\"value\":\"[Product](https://www.walmart.com/ip/prada/%s)\"}],\"footer\":{\"text\":\"Prada#4873\"},\"timestamp\":\"2021-04-01T18:40:00.000Z\",\"thumbnail\":{\"url\":\"%s\"}}],\"avatar_url\":\"https://cdn.discordapp.com/attachments/815507198394105867/816741454922776576/pfp.png\"}",m.Config.site, m.monitorProduct.name, m.monitorProduct.stockNumber, m.Config.tcin, m.Config.image))
	req, err := http.NewRequest("POST", m.Config.discord, payload)
	if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return nil
	}
	req.Header.Add("authority", "discord.com")
	req.Header.Add("pragma", "no-cache")
	req.Header.Add("cache-control", "no-cache")
	req.Header.Add("accept", "application/json")
	req.Header.Add("dnt", "1")
	req.Header.Add("accept-language", "en")
	req.Header.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36")
	req.Header.Add("content-type", "application/json")
	req.Header.Add("sec-fetch-site", "cross-site")
	req.Header.Add("sec-fetch-mode", "cors")
	req.Header.Add("sec-fetch-dest", "empty")
	res, err := m.Client.Do(req)
	if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return nil
	}
	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
			fmt.Println(err)
			m.file.WriteString(err.Error() + "\n")
			return nil
		}
	fmt.Println(res)
	fmt.Println(string(body))
	return nil
}

func (m *Monitor) getProductImage (tcin string) {
	fmt.Println("Getting Product Image")
	url := fmt.Sprintf("https://www.target.com/p/-/A-%s`", tcin)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return 
	}
	res, err := m.Client.Do(req)
		if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return 
	}
	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)
		if err != nil {
		fmt.Println(err)
		m.file.WriteString(err.Error() + "\n")
		return 
	}
	fmt.Println(res.StatusCode)
	
	firstPart:= (strings.Split(string(body), `<img alt="" src="`)[1])
	testImage := strings.Split(firstPart, `"`)[0]
	m.Config.image = testImage
	fmt.Println(testImage)
	return
}
